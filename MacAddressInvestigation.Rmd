---
title: "MAC Addresses"
output: html_notebook
---

Conduct a more thorough data analysis into these two MAC addresses including determining locations by using data corresponding to both MAC addresses.  Which of these two MAC addresses should be used and which should not be used for RTLS? Which MAC address yields the best prediction of location?  Does using data for both MAC addresses simultaneously yield more, or less, accurate prediction of location? (Note: this portion is derived from Exercise Q.9 in Nolan and Lang.)

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(ggthemes)

```


This sounds like we are trying to compare three different modeling methods for location finding:
1.  Keep 00:0f:a3:39:e1:c0 and to eliminate the data corresponding to MAC address 00:0f:a3:39:dd:cd. 
2.  Drop 00:0f:a3:39:e1:c0 and to keep the data corresponding to MAC address 00:0f:a3:39:dd:cd. 
3.  Keep both

Our evaluation criteria needs to speak to accuracy - which I would interpret as a higher confidence in the predictions - so having a smaller confidence interval band.

We know our location
We figured out the location of the access points.  Two are at the same location.  One was left out of the analysis.
Could probably describe the location of access points 
We know relationships of access points, test locations, signal strengths


Signal Strength = angle + distance(x, y)

```{r}
list <- c("00:0f:a3:39:e1:c0", "00:0f:a3:39:dd:cd")

offline %>% mutate(signal = as.numeric(signal)) %>% filter(mac %in% list) %>% ggplot(aes(x=signal)) + geom_histogram() + theme_light() + facet_wrap(~mac, ncol=2)

```
```{r}
offline %>% ggplot(aes(x=posX, y=posY)) + geom_point(alpha=0.05) + theme_light() + facet_grid(~mac)+ geom_jitter()

```
#Heatmap of each of the two options
```{r}

parCur = par(mfrow = c(4,2), mar = rep(1, 4)) 

mapply(surfaceSS, mac = "00:0f:a3:39:e1:c0", angle = rep(c(0, 135,180, 270), 2), data = list(data = offlineSummary))

par(parCur)

#Nolan, Deborah; Lang, Duncan Temple. Data Science in R: A Case Studies Approach to Computational Reasoning and Problem Solving (Chapman & Hall/CRC The R Series) (Page 28). CRC Press. Kindle Edition. 

```

```{r}
#This is the one that was dropped
compareMacList <- c("00:0f:a3:39:dd:cd", "00:0f:a3:39:e1:c0")
offlineSummary2 = do.call("rbind", signalSummary)     

parCur = par(mfrow = c(2,2), mar = rep(1, 4)) 

mapply(surfaceSS, mac = compareMacList[rep(c(1,2), each=2)], angle = rep(c(90, 135), 2), data = list(data = offlineSummary2))

par(parCur)

#surfaceSS(mac="00:0f:a3:39:e1:c0", angle = 180, data = offlineSummary2)

#Nolan, Deborah; Lang, Duncan Temple. Data Science in R: A Case Studies Approach to Computational Reasoning and Problem Solving (Chapman & Hall/CRC The R Series) (Page 28). CRC Press. Kindle Edition. 

unique(offlineSummary2$orientation)

```
The access point that was eliminated, shown on the bottom, seems to have some greater uncertainty associated with it. While there's a zone of uncertainty associated with the first, it has a higher degree of certainty and strength of signal close to the suspected base.  



#Keep e1:c0
```{r}
#This is the same as the existing solution, so I don't see anything we need to do outside of run the existing code and say what the value is for error
# cross validate over each location, using all 8 orientations and 6 MAC addresses
# each fold has 166/11 = 15 locations
# must randomly select
v = 11
# permute locations
permuteLocs = sample(unique(offlineSummary$posXY))

# to calculate folds, build a matrix with 11 columns and ~15 locations each
permuteLocs = matrix(permuteLocs, ncol = v, 
                     nrow = floor(length(permuteLocs)/v))

# get the first validation fold from our offline data
onlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])

# must re-summarize each fold to match onlineSummary format
# selecting orientation at random to create our CV folds
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

# exclude MAC
offline2 = offline[ offline$mac != "00:0f:a3:39:dd:cd", ]

keepVars = c("posXY", "posX","posY", "orientation", "angle")

# build CV base from offline data in general
onlineCVSummary = reshapeSS(offline2, keepVars = keepVars, 
                            sampleAngle = TRUE)

# an example of one fold
onlineFold = subset(onlineCVSummary, 
                    posXY %in% permuteLocs[ , 1])

# this is our training set
offlineFold = subset(offlineSummary,
                     posXY %in% permuteLocs[ , -1])

# using both methods with k = 3
estFold = predXY(newSignals = onlineFold[ , 6:11], 
                 newAngles = onlineFold[ , 4], 
                 offlineFold, numAngles = 3, k = 3)

estFoldwtd = predXYwtd(newSignals = onlineFold[ , 6:11], 
                 newAngles = onlineFold[ , 4], 
                 offlineFold, numAngles = 3, k = 3)

actualFold = onlineFold[ , c("posX", "posY")]
calcError(estFoldwtd, actualFold)

# formally test K out to 20 neighbors
K = 20
err = rep(0, K)
err_wtd = rep(0,K) # weighted error

for (j in 1:v) {
  onlineFold = subset(onlineCVSummary, 
                      posXY %in% permuteLocs[ , j])
  offlineFold = subset(offlineSummary,
                       posXY %in% permuteLocs[ , -j])
  actualFold = onlineFold[ , c("posX", "posY")]
  
  for (k in 1:K) {
    estFold = predXY(newSignals = onlineFold[ , 6:11],
                     newAngles = onlineFold[ , 4], 
                     offlineFold, numAngles = 3, k = k)
    err[k] = err[k] + calcError(estFold, actualFold)
    
    estFold_wtd = predXYwtd(newSignals = onlineFold[ , 6:11], # add in weighted calculations
                     newAngles = onlineFold[ , 4], 
                     offlineFold, numAngles = 3, k = k)
    err_wtd[k] = err_wtd[k] + calcError(estFold_wtd, actualFold)
  }
}

#pdf(file = "Images/Geo_CVChoiceOfK.pdf", width = 8, height = 6)
oldPar = par(mar = c(4, 3, 1, 1))
plot(y = err, x = (1:K),  type = "l", lwd= 2,
     ylim = c(0, 2100),
     xlab = "Number of Neighbors",
     ylab = "Sum of Square Errors")
lines(y=err_wtd, x=1:K, lty = 2, lwd=2, col='red')


rmseMin = min(err)
kMin = which(err == rmseMin)[1]

rmseMin_wtd = min(err_wtd)
kMin_wtd = which(err_wtd == rmseMin_wtd)[1]



```


#Keep dd:cd
```{r}
#Replace e1:c0 with dd:cd in the training data, retrain model, then reevaluate performance
# cross validate over each location, using all 8 orientations and 6 MAC addresses
# each fold has 166/11 = 15 locations
# must randomly select
v = 11
# permute locations
permuteLocs = sample(unique(offlineSummary$posXY))

# to calculate folds, build a matrix with 11 columns and ~15 locations each
permuteLocs = matrix(permuteLocs, ncol = v, 
                     nrow = floor(length(permuteLocs)/v))

# get the first validation fold from our offline data
onlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])

# must re-summarize each fold to match onlineSummary format
# selecting orientation at random to create our CV folds
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

# exclude MAC
offline3 = offline[ offline$mac != "00:0f:a3:39:e1:c0", ]

keepVars = c("posXY", "posX","posY", "orientation", "angle")

# build CV base from offline data in general
onlineCVSummary = reshapeSS(offline3, keepVars = keepVars, 
                            sampleAngle = TRUE)

# an example of one fold
onlineFold = subset(onlineCVSummary, 
                    posXY %in% permuteLocs[ , 1])

# this is our training set
offlineFold = subset(offlineSummary,
                     posXY %in% permuteLocs[ , -1])

# using both methods with k = 3
estFold = predXY(newSignals = onlineFold[ , 6:11], 
                 newAngles = onlineFold[ , 4], 
                 offlineFold, numAngles = 3, k = 3)

estFoldwtd = predXYwtd(newSignals = onlineFold[ , 6:11], 
                 newAngles = onlineFold[ , 4], 
                 offlineFold, numAngles = 3, k = 3)

actualFold = onlineFold[ , c("posX", "posY")]
calcError(estFoldwtd, actualFold)

# formally test K out to 20 neighbors
K = 20
err = rep(0, K)
err_wtd = rep(0,K) # weighted error

for (j in 1:v) {
  onlineFold = subset(onlineCVSummary, 
                      posXY %in% permuteLocs[ , j])
  offlineFold = subset(offlineSummary,
                       posXY %in% permuteLocs[ , -j])
  actualFold = onlineFold[ , c("posX", "posY")]
  
  for (k in 1:K) {
    estFold = predXY(newSignals = onlineFold[ , 6:11],
                     newAngles = onlineFold[ , 4], 
                     offlineFold, numAngles = 3, k = k)
    err[k] = err[k] + calcError(estFold, actualFold)
    
    estFold_wtd = predXYwtd(newSignals = onlineFold[ , 6:11], # add in weighted calculations
                     newAngles = onlineFold[ , 4], 
                     offlineFold, numAngles = 3, k = k)
    err_wtd[k] = err_wtd[k] + calcError(estFold_wtd, actualFold)
  }
}

pdf(file = "Images/Geo_CVChoiceOfK.pdf", width = 8, height = 6)
oldPar = par(mar = c(4, 3, 1, 1))
plot(y = err, x = (1:K),  type = "l", lwd= 2,
     ylim = c(0, 2100),
     xlab = "Number of Neighbors",
     ylab = "Sum of Square Errors")
lines(y=err_wtd, x=1:K, lty = 2, lwd=2, col='red')


rmseMin = min(err)
kMin = which(err == rmseMin)[1]

rmseMin_wtd = min(err_wtd)
kMin_wtd = which(err_wtd == rmseMin_wtd)[1]


# FINDING NEAREST NEIGHBORS
# takes numeric vector of 6 new signal strengths and result of selectTrain() training set
findNN = function(newSignal, trainSubset) {
  diffs = apply(trainSubset[ , 4:9], 1, 
                function(x) x - newSignal) # this inverts, places x,y on cols when called as.numeric
  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) # this gets our distance (euclidean)
  closest = order(dists) # orders our distances in ascending
  return(trainSubset[closest, 1:3 ]) # returns the subset from training with closest distances, gives xy ID, x, y
}


# weighted nearest neighbors, returns numerator of weight 1/distance
findWtdNN = function(newSignal, trainSubset) {
  diffs = apply(trainSubset[ , 4:9], 1, 
                function(x) x - newSignal) 
  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) 
  closest = order(dists) # orders distances ascending
  closeXY = trainSubset[closest, 1:3 ]
  weight = as.numeric(1/dists[closest]) # calculate numerator for weights, we'll filter these based on K in predXY
  return(cbind(closeXY, weight)) # add in numerator for our weights
}

# prediction using nearest neighbors from training set
predXY = function(newSignals, newAngles, trainData, 
                  numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles) # select training set based on angle of test obs, num of angles in proximity
    closeXY[[i]] = findNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # find nearest neighbors, return closest in training set
  }
  estXY = lapply(closeXY, # loop over each xy position-based dataframe
                 function(x) sapply(x[ , 2:3], 
                                    function(x) mean(x[1:k]))) # take a simple average of x,y positions
  estXY = do.call("rbind", estXY) # pull predictions together for each observation xy in test set
  return(estXY)
}

# weighted prediction
predXYwtd = function(newSignals, newAngles, trainData, 
                     numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
    base = findWtdNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # get matrix of x,y, numerator for weights
    wts = append(base[1:k, 4]/sum(base[1:k, 4]), rep(0, nrow(base)-k))  # calculate weights based on K, append zero array for delta of len-k
    base[, 2:3] = base[, 2:3]*wts # multiply weights array * matrix of x,y to get weighted vals
    closeXY[[i]] = base[,1:3] # append weighted xy, x, y values to list
  }
  estXY = lapply(closeXY, # loop over each xy position-based dataframe
                 function(x) sapply(x[ , 2:3], function(x) sum(x))) # sum all as neighbors > k == 0 now, and x,y is already weighted!
  estXY = do.call("rbind", estXY) # pull predictions together for each observation xy in test set
  return(estXY)
}

```

#Keep Both Data
```{r}
# cross validate over each location, using all 8 orientations and 6 MAC addresses
# each fold has 166/11 = 15 locations
# must randomly select
v = 11
# permute locations
permuteLocs = sample(unique(offlineSummary$posXY))

# to calculate folds, build a matrix with 11 columns and ~15 locations each
permuteLocs = matrix(permuteLocs, ncol = v, 
                     nrow = floor(length(permuteLocs)/v))

# get the first validation fold from our offline data
onlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])

# must re-summarize each fold to match onlineSummary format
# selecting orientation at random to create our CV folds
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

# exclude MAC
#commented this out for the "keep both" question
#offline = offline[ offline$mac != "00:0f:a3:39:dd:cd", ]

keepVars = c("posXY", "posX","posY", "orientation", "angle")

# build CV base from offline data in general
onlineCVSummary = reshapeSS(offline2, keepVars = keepVars, 
                            sampleAngle = TRUE)

# an example of one fold
onlineFold = subset(onlineCVSummary, 
                    posXY %in% permuteLocs[ , 1])

# this is our training set
offlineFold = subset(offlineSummary,
                     posXY %in% permuteLocs[ , -1])

# using both methods with k = 3
estFold = predXY(newSignals = onlineFold[ , 6:11], 
                 newAngles = onlineFold[ , 4], 
                 offlineFold, numAngles = 3, k = 3)

estFoldwtd = predXYwtd(newSignals = onlineFold[ , 6:11], 
                 newAngles = onlineFold[ , 4], 
                 offlineFold, numAngles = 3, k = 3)

actualFold = onlineFold[ , c("posX", "posY")]
calcError(estFoldwtd, actualFold)

# formally test K out to 20 neighbors
K = 20
err = rep(0, K)
err_wtd = rep(0,K) # weighted error

for (j in 1:v) {
  onlineFold = subset(onlineCVSummary, 
                      posXY %in% permuteLocs[ , j])
  offlineFold = subset(offlineSummary,
                       posXY %in% permuteLocs[ , -j])
  actualFold = onlineFold[ , c("posX", "posY")]
  
  for (k in 1:K) {
    estFold = predXY(newSignals = onlineFold[ , 6:11],
                     newAngles = onlineFold[ , 4], 
                     offlineFold, numAngles = 3, k = k)
    err[k] = err[k] + calcError(estFold, actualFold)
    
    estFold_wtd = predXYwtd(newSignals = onlineFold[ , 6:11], # add in weighted calculations
                     newAngles = onlineFold[ , 4], 
                     offlineFold, numAngles = 3, k = k)
    err_wtd[k] = err_wtd[k] + calcError(estFold_wtd, actualFold)
  }
}

#pdf(file = "Images/Geo_CVChoiceOfK.pdf", width = 8, height = 6)
oldPar = par(mar = c(4, 3, 1, 1))
plot(y = err, x = (1:K),  type = "l", lwd= 2,
     ylim = c(0, 2100),
     xlab = "Number of Neighbors",
     ylab = "Sum of Square Errors")
lines(y=err_wtd, x=1:K, lty = 2, lwd=2, col='red')


rmseMin = min(err)
kMin = which(err == rmseMin)[1]

rmseMin_wtd = min(err_wtd)
kMin_wtd = which(err_wtd == rmseMin_wtd)[1]



```