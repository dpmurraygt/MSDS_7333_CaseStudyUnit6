"0","length(train130[[1]])"
"1","[1]"
"1"," 166"
"1","
"
"0","# FINDING NEAREST NEIGHBORS"
"0","# takes numeric vector of 6 new signal strengths and result of selectTrain() training set"
"0","findNN = function(newSignal, trainSubset) {"
"0","  diffs = apply(trainSubset[ , 4:9], 1, "
"0","                function(x) x - newSignal) # this inverts, places x,y on cols when called as.numeric"
"0","  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) # this gets our distance (euclidean)"
"0","  closest = order(dists) # orders our distances in ascending"
"0","  return(trainSubset[closest, 1:3 ]) # returns the subset from training with closest distances, gives xy ID, x, y"
"0","}"
"0","# weighted nearest neighbors, returns numerator of weight 1/distance"
"0","findWtdNN = function(newSignal, trainSubset) {"
"0","  diffs = apply(trainSubset[ , 4:9], 1, "
"0","                function(x) x - newSignal) "
"0","  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) "
"0","  closest = order(dists) # orders distances ascending"
"0","  closeXY = trainSubset[closest, 1:3 ]"
"0","  weight = as.numeric(1/dists[closest]) # calculate numerator for weights, we'll filter these based on K in predXY"
"0","  return(cbind(closeXY, weight)) # add in numerator for our weights"
"0","}"
"0","# prediction using nearest neighbors from training set"
"0","predXY = function(newSignals, newAngles, trainData, "
"0","                  numAngles = 1, k = 3){"
"0","  "
"0","  closeXY = list(length = nrow(newSignals))"
"0","  "
"0","  for (i in 1:nrow(newSignals)) {"
"0","    trainSS = selectTrain(newAngles[i], trainData, m = numAngles) # select training set based on angle of test obs, num of angles in proximity"
"0","    closeXY[[i]] = findNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # find nearest neighbors, return closest in training set"
"0","  }"
"0","  estXY = lapply(closeXY, # loop over each xy position-based dataframe"
"0","                 function(x) sapply(x[ , 2:3], "
"0","                                    function(x) mean(x[1:k]))) # take a simple average of x,y positions"
"0","  estXY = do.call(""rbind"", estXY) # pull predictions together for each observation xy in test set"
"0","  return(estXY)"
"0","}"
"0","# weighted prediction"
"0","predXYwtd = function(newSignals, newAngles, trainData, "
"0","                     numAngles = 1, k = 3){"
"0","  "
"0","  closeXY = list(length = nrow(newSignals))"
"0","  "
"0","  for (i in 1:nrow(newSignals)) {"
"0","    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)"
"0","    base = findWtdNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # get matrix of x,y, numerator for weights"
"0","    wts = append(base[1:k, 4]/sum(base[1:k, 4]), rep(0, nrow(base)-k))  # calculate weights based on K, append zero array for delta of len-k"
"0","    base[, 2:3] = base[, 2:3]*wts # multiply weights array * matrix of x,y to get weighted vals"
"0","    closeXY[[i]] = base[,1:3] # append weighted xy, x, y values to list"
"0","  }"
"0","  estXY = lapply(closeXY, # loop over each xy position-based dataframe"
"0","                 function(x) sapply(x[ , 2:3], function(x) sum(x))) # sum all as neighbors > k == 0 now, and x,y is already weighted!"
"0","  estXY = do.call(""rbind"", estXY) # pull predictions together for each observation xy in test set"
"0","  return(estXY)"
"0","}"
