{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Unit 6 Case Study 3\"\noutput: html_notebook\n---\n\n\n```{r}\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(fields)\nlibrary(lattice)\n\n```\n\n```{r}\n#This is the code from Nolan and Lang Chapter 1\noptions(digits = 2)\n\ntxt = readLines(\"Data/offline.final.trace.txt\")\n\nsum(substr(txt, 1, 1) == \"#\")\n\nlength(txt)\n\nstrsplit(txt[4], \";\")[[1]]\n\ntokens = strsplit(txt[4], \"[;=,]\")[[1]]\n\ntokens[1:10]\n\ntokens[c(2, 4, 6:8, 10)]\n\ntokens[ - ( 1:10 ) ]\n\ntmp = matrix(tokens[ - (1:10) ], ncol = 4, byrow = TRUE)\nmat = cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow = nrow(tmp),\n                   ncol = 6, byrow = TRUE), \n            tmp)\n\ndim(mat)\n\nprocessLine =\nfunction(x)\n{\n  tokens = strsplit(x, \"[;=,]\")[[1]]\n  tmp = matrix(tokens[ - (1:10) ], ncol = 4, byrow = TRUE)\n  cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow = nrow(tmp),\n               ncol = 6, byrow = TRUE), tmp)\n}\n\ntmp = lapply(txt[4:20], processLine)\n\nsapply(tmp, nrow)\n\noffline = as.data.frame(do.call(\"rbind\", tmp))\ndim(offline)\n\nlines = txt[ substr(txt, 1, 1) != \"#\" ]\ntmp = lapply(lines, processLine)\n\nprocessLine = function(x)\n{\n  tokens = strsplit(x, \"[;=,]\")[[1]]\n  \n  if (length(tokens) == 10) \n    return(NULL)\n \n  tmp = matrix(tokens[ - (1:10) ], , 4, byrow = TRUE)\n  cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow(tmp), 6, \n               byrow = TRUE), tmp)\n}\n\noptions(error = recover, warn = 1)\ntmp = lapply(lines, processLine)\noffline = as.data.frame(do.call(\"rbind\", tmp), \n                        stringsAsFactors = FALSE)\n\ndim(offline)\n\nnames(offline) = c(\"time\", \"scanMac\", \"posX\", \"posY\", \"posZ\", \n                   \"orientation\", \"mac\", \"signal\", \n                   \"channel\", \"type\")\n\nnumVars = c(\"time\", \"posX\", \"posY\", \"posZ\", \n            \"orientation\", \"signal\")\noffline[ numVars ] =  lapply(offline[ numVars ], as.numeric)\n\noffline = offline[ offline$type == \"3\", ]\noffline = offline[ , \"type\" != names(offline) ]\ndim(offline)\n\noffline$rawTime = offline$time\noffline$time = offline$time/1000\nclass(offline$time) = c(\"POSIXt\", \"POSIXct\")\n\nunlist(lapply(offline, class))\n\nsummary(offline[, numVars])\n\n summary(sapply(offline[ , c(\"mac\", \"channel\", \"scanMac\")],\n                as.factor))\n\noffline = offline[ , !(names(offline) %in% c(\"scanMac\", \"posZ\"))]\n\nlength(unique(offline$orientation))\n\nplot(ecdf(offline$orientation))\n\npdf(file = \"Geo_ECDFOrientation.pdf\", width = 10, height = 7)\noldPar = par(mar = c(4, 4, 1, 1))\nplot(ecdf(offline$orientation), pch = 19, cex = 0.3,\n     xlim = c(-5, 365), axes = FALSE,\n     xlab = \"orientation\", ylab = \"Empirical CDF\", main = \"\")\nbox()\naxis(2)\naxis(side = 1, at = seq(0, 360, by = 45))\npar(oldPar)\ndev.off()\n\npdf(file = \"Geo_DensityOrientation.pdf\", width = 10, height = 5)\noldPar = par(mar = c(4, 4, 1, 1))\nplot(density(offline$orientation, bw = 2), \n xlab = \"orientation\", main = \"\")\npar(oldPar)\ndev.off()\n\nroundOrientation = function(angles) {\n  refs = seq(0, by = 45, length  = 9)\n  q = sapply(angles, function(o) which.min(abs(o - refs)))\n  c(refs[1:8], 0)[q]\n}\n\noffline$angle = roundOrientation(offline$orientation)\n\npdf(file = \"Geo_BoxplotAngle.pdf\", width = 10)\noldPar = par(mar = c(4, 4, 1, 1))\n\npar(oldPar)\ndev.off()\n\nc(length(unique(offline$mac)), length(unique(offline$channel)))\n\ntable(offline$mac)\n\nsubMacs = names(sort(table(offline$mac), decreasing = TRUE))[1:7]\noffline = offline[ offline$mac %in% subMacs, ]\n\nmacChannel = with(offline, table(mac, channel))\napply(macChannel, 1, function(x) sum(x > 0))\n\noffline = offline[ , \"channel\" != names(offline)]\n\nlocDF = with(offline, \n             by(offline, list(posX, posY), function(x) x))\nlength(locDF)\n\n\nsum(sapply(locDF, is.null))\n\nlocDF = locDF[ !sapply(locDF, is.null) ]\n\nlength(locDF)\n\nlocCounts = sapply(locDF, nrow)\n\nlocCounts = sapply(locDF, \n                   function(df) \n                     c(df[1, c(\"posX\", \"posY\")], count = nrow(df)))\n\nclass(locCounts)\n\ndim(locCounts)\n\nlocCounts[ , 1:8]\n\npdf(file = \"Geo_XYByCount.pdf\", width = 10)\noldPar = par(mar = c(3.1, 3.1, 1, 1))\n\nlocCounts = t(locCounts)\nplot(locCounts, type = \"n\", xlab = \"\", ylab = \"\")\ntext(locCounts, labels = locCounts[,3], cex = .8, srt = 45)\n\npar(oldPar)\ndev.off()\n\nreadData = \n  function(filename = 'Data/offline.final.trace.txt', \n           subMacs = c(\"00:0f:a3:39:e1:c0\", \"00:0f:a3:39:dd:cd\", \"00:14:bf:b1:97:8a\",\n                       \"00:14:bf:3b:c7:c6\", \"00:14:bf:b1:97:90\", \"00:14:bf:b1:97:8d\",\n                       \"00:14:bf:b1:97:81\"))\n  {\n    txt = readLines(filename)\n    lines = txt[ substr(txt, 1, 1) != \"#\" ]\n    tmp = lapply(lines, processLine)\n    offline = as.data.frame(do.call(\"rbind\", tmp), \n                            stringsAsFactors= FALSE) \n    \n    names(offline) = c(\"time\", \"scanMac\", \n                       \"posX\", \"posY\", \"posZ\", \"orientation\", \n                       \"mac\", \"signal\", \"channel\", \"type\")\n    \n     # keep only signals from access points\n    offline = offline[ offline$type == \"3\", ]\n    \n    # drop scanMac, posZ, channel, and type - no info in them\n    dropVars = c(\"scanMac\", \"posZ\", \"channel\", \"type\")\n    offline = offline[ , !( names(offline) %in% dropVars ) ]\n    \n    # drop more unwanted access points\n    offline = offline[ offline$mac %in% subMacs, ]\n    \n    # convert numeric values\n    numVars = c(\"time\", \"posX\", \"posY\", \"orientation\", \"signal\")\n    offline[ numVars ] = lapply(offline[ numVars ], as.numeric)\n\n    # convert time to POSIX\n    offline$rawTime = offline$time\n    offline$time = offline$time/1000\n    class(offline$time) = c(\"POSIXt\", \"POSIXct\")\n    \n    # round orientations to nearest 45\n    offline$angle = roundOrientation(offline$orientation)\n      \n    return(offline)\n  }\n\nofflineRedo = readData()\n\nidentical(offline, offlineRedo)\n\npdf(file = \"Geo_BoxplotSignalByMacAngle.pdf\", width = 7)\noldPar = par(mar = c(3.1, 3, 1, 1))\n\nlibrary(lattice)\nbwplot(signal ~ factor(angle) | mac, data = offline, \n       subset = posX == 2 & posY == 12 \n                & mac != \"00:0f:a3:39:dd:cd\", \n       layout = c(2,3))\n\npar(oldPar)\ndev.off()\n\nsummary(offline$signal)\n\npdf(file = \"Geo_DensitySignalByMacAngle.pdf\", width = 8, height = 12)\noldPar = par(mar = c(3.1, 3, 1, 1))\n\ndensityplot( ~ signal | mac + factor(angle), data = offline,\n             subset = posX == 24 & posY == 4 & \n                         mac != \"00:0f:a3:39:dd:cd\",\n             bw = 0.5, plot.points = FALSE)\n\npar(oldPar)\ndev.off()\n\n#offline = offline[ offline$mac != \"00:0f:a3:39:dd:cd\", ]\n\noffline$posXY = paste(offline$posX, offline$posY, sep = \"-\")\n\nbyLocAngleAP = with(offline, \n                    by(offline, list(posXY, angle, mac), \n                       function(x) x))\n\nsignalSummary = \n  lapply(byLocAngleAP,            \n         function(oneLoc) {\n           ans = oneLoc[1, ]\n           ans$medSignal = median(oneLoc$signal)\n           ans$avgSignal = mean(oneLoc$signal)\n           ans$num = length(oneLoc$signal)\n           ans$sdSignal = sd(oneLoc$signal)\n           ans$iqrSignal = IQR(oneLoc$signal)\n           ans\n           })\n\nofflineSummary = do.call(\"rbind\", signalSummary)     \n\npdf(file = \"Geo_BoxplotSignalSDByAvg.pdf\", width = 10)\noldPar = par(mar = c(3.1, 3, 1, 1))\n\nbreaks = seq(-90, -30, by = 5)\nbwplot(sdSignal ~ cut(avgSignal, breaks = breaks),\n       data = offlineSummary, \n       subset = mac != \"00:0f:a3:39:dd:cd\",\n       xlab = \"Mean Signal\", ylab = \"SD Signal\")\n\npar(oldPar)\ndev.off()\n\npdf(file = \"Geo_ScatterMean-Median.pdf\", width = 10)\noldPar = par(mar = c(4.1, 4.1, 1, 1))\n\nwith(offlineSummary,\n     smoothScatter((avgSignal - medSignal) ~ num,\n                   xlab = \"Number of Observations\", \n                   ylab = \"mean - median\"))\nabline(h = 0, col = \"#984ea3\", lwd = 2)\n\nlo.obj = \n  with(offlineSummary,\n       loess(diff ~ num, \n             data = data.frame(diff = (avgSignal - medSignal),\n                               num = num)))\n\nlo.obj.pr = predict(lo.obj, newdata = data.frame(num = (70:120)))\nlines(x = 70:120, y = lo.obj.pr, col = \"#4daf4a\", lwd = 2)\n\npar(oldPar)\ndev.off()\n \noneAPAngle = subset(offlineSummary, \n                    mac == subMacs[5] & angle == 0)\n\n\nlibrary(fields)\nsmoothSS = Tps(oneAPAngle[, c(\"posX\",\"posY\")], \n               oneAPAngle$avgSignal)\n\nvizSmooth = predictSurface(smoothSS)\n\nplot.surface(vizSmooth, type = \"C\")\n\npoints(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)\n\nsurfaceSS = function(data, mac, angle = 45) {\n  require(fields)\n  oneAPAngle = data[ data$mac == mac & data$angle == angle, ]\n  smoothSS = Tps(oneAPAngle[, c(\"posX\",\"posY\")], \n                 oneAPAngle$avgSignal)\n  vizSmooth = predictSurface(smoothSS)\n  plot.surface(vizSmooth, type = \"C\", \n               xlab = \"\", ylab = \"\", xaxt = \"n\", yaxt = \"n\")\n  points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5) \n}\n\nparCur = par(mfrow = c(2,2), mar = rep(1, 4))\n\nmapply(surfaceSS, mac = subMacs[ rep(c(5, 1), each = 2) ], \n       angle = rep(c(0, 135), 2),\n       data = list(data = offlineSummary))\n \npar(parCur)\n\nofflineSummary = subset(offlineSummary, mac != subMacs[2])\n\nAP = matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,  \n                1, 14, 33.5, 9.3,  33.5, 2.8),\n            ncol = 2, byrow = TRUE,\n            dimnames = list(subMacs[ -2 ], c(\"x\", \"y\") ))\n\nAP\n\ndiffs = offlineSummary[ , c(\"posX\", \"posY\")] - \n          AP[ offlineSummary$mac, ]\n\nofflineSummary$dist = sqrt(diffs[ , 1]^2 + diffs[ , 2]^2)\n\nxyplot(signal ~ dist | factor(mac) + factor(angle), \n       data = offlineSummary, pch = 19, cex = 0.3,\n       xlab =\"distance\")\n\npdf(file=\"Geo_ScatterSignalDist.pdf\", width = 7, height = 10)\noldPar = par(mar = c(3.1, 3.1, 1, 1))\nlibrary(lattice)\nxyplot(signal ~ dist | factor(mac) + factor(angle), \n       data = offlineSummary, pch = 19, cex = 0.3,\n       xlab =\"distance\")\npar(oldPar)\ndev.off()\n\nmacs = unique(offlineSummary$mac)\nonline = readData(\"Data/online.final.trace.txt\", subMacs = macs)\n\nonline$posXY = paste(online$posX, online$posY, sep = \"-\")\n\nlength(unique(online$posXY))\n\ntabonlineXYA = table(online$posXY, online$angle)\ntabonlineXYA[1:6, ]\n\nkeepVars = c(\"posXY\", \"posX\",\"posY\", \"orientation\", \"angle\")\nbyLoc = with(online, \n             by(online, list(posXY), \n                function(x) {\n                  ans = x[1, keepVars]\n                  avgSS = tapply(x$signal, x$mac, mean)\n                  y = matrix(avgSS, nrow = 1, ncol = 6,\n                        dimnames = list(ans$posXY, names(avgSS)))\n                  cbind(ans, y)\n                }))\n\nonlineSummary = do.call(\"rbind\", byLoc)  \n\ndim(onlineSummary)\n\nnames(onlineSummary)\nm = 3; angleNewObs = 230\nrefs = seq(0, by = 45, length  = 8)\nnearestAngle = roundOrientation(angleNewObs)\n  \nif (m %% 2 == 1) {\n  angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)\n} else {\n  m = m + 1\n  angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)\n  if (sign(angleNewObs - nearestAngle) > -1) \n    angles = angles[ -1 ]\n  else \n    angles = angles[ -m ]\n}\nangles = angles + nearestAngle\nangles[angles < 0] = angles[ angles < 0 ] + 360\nangles[angles > 360] = angles[ angles > 360 ] - 360\n\nofflineSubset = \n  offlineSummary[ offlineSummary$angle %in% angles, ]\n\nreshapeSS = function(data, varSignal = \"signal\", \n                     keepVars = c(\"posXY\", \"posX\",\"posY\")) {\n  byLocation =\n    with(data, by(data, list(posXY), \n                  function(x) {\n                    ans = x[1, keepVars]\n                    avgSS = tapply(x[ , varSignal ], x$mac, mean)\n                    y = matrix(avgSS, nrow = 1, ncol = 6,\n                               dimnames = list(ans$posXY,\n                                               names(avgSS)))\n                    cbind(ans, y)\n                  }))\n\n  newDataSS = do.call(\"rbind\", byLocation)\n  return(newDataSS)\n}\n\ntrainSS = reshapeSS(offlineSubset, varSignal = \"avgSignal\")\n\nselectTrain = function(angleNewObs, signals = NULL, m = 1){\n  # m is the number of angles to keep between 1 and 5\n  refs = seq(0, by = 45, length  = 8)\n  nearestAngle = roundOrientation(angleNewObs)\n  \n  if (m %% 2 == 1) \n    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)\n  else {\n    m = m + 1\n    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)\n    if (sign(angleNewObs - nearestAngle) > -1) \n      angles = angles[ -1 ]\n    else \n      angles = angles[ -m ]\n  }\n  angles = angles + nearestAngle\n  angles[angles < 0] = angles[ angles < 0 ] + 360\n  angles[angles > 360] = angles[ angles > 360 ] - 360\n  angles = sort(angles) \n  \n  offlineSubset = signals[ signals$angle %in% angles, ]\n  reshapeSS(offlineSubset, varSignal = \"avgSignal\")\n}\n\ntrain130 = selectTrain(130, offlineSummary, m = 3)\n\nhead(train130)\n\nlength(train130[[1]])\n\nfindNN = function(newSignal, trainSubset) {\n  diffs = apply(trainSubset[ , 4:9], 1, \n                function(x) x - newSignal)\n  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) )\n  closest = order(dists)\n  return(trainSubset[closest, 1:3 ])\n}\n\npredXY = function(newSignals, newAngles, trainData, \n                  numAngles = 1, k = 3){\n  \n  closeXY = list(length = nrow(newSignals))\n  \n  for (i in 1:nrow(newSignals)) {\n    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)\n    closeXY[[i]] = \n      findNN(newSignal = as.numeric(newSignals[i, ]), trainSS)\n  }\n\n  estXY = lapply(closeXY, \n                 function(x) sapply(x[ , 2:3], \n                                    function(x) mean(x[1:k])))\n  estXY = do.call(\"rbind\", estXY)\n  return(estXY)\n}\nestXYk3 = predXY(newSignals = onlineSummary[ , 6:11], \n                 newAngles = onlineSummary[ , 4], \n                 offlineSummary, numAngles = 3, k = 3)\n\nestXYk1 = predXY(newSignals = onlineSummary[ , 6:11], \n                 newAngles = onlineSummary[ , 4], \n                 offlineSummary, numAngles = 3, k = 1)\n\nfloorErrorMap = function(estXY, actualXY, trainPoints = NULL, AP = NULL){\n  \n    plot(0, 0, xlim = c(0, 35), ylim = c(-3, 15), type = \"n\",\n         xlab = \"\", ylab = \"\", axes = FALSE)\n    box()\n    if ( !is.null(AP) ) points(AP, pch = 15)\n    if ( !is.null(trainPoints) )\n      points(trainPoints, pch = 19, col=\"grey\", cex = 0.6)\n    \n    points(x = actualXY[, 1], y = actualXY[, 2], \n           pch = 19, cex = 0.8 )\n    points(x = estXY[, 1], y = estXY[, 2], \n           pch = 8, cex = 0.8 )\n    segments(x0 = estXY[, 1], y0 = estXY[, 2],\n             x1 = actualXY[, 1], y1 = actualXY[ , 2],\n             lwd = 2, col = \"red\")\n}\n\ntrainPoints = offlineSummary[ offlineSummary$angle == 0 & \n                              offlineSummary$mac == \"00:0f:a3:39:e1:c0\" ,\n                        c(\"posX\", \"posY\")]\n\npdf(file=\"GEO_FloorPlanK3Errors.pdf\", width = 10, height = 7)\noldPar = par(mar = c(1, 1, 1, 1))\nfloorErrorMap(estXYk3, onlineSummary[ , c(\"posX\",\"posY\")], \n              trainPoints = trainPoints, AP = AP)\npar(oldPar)\ndev.off()\n\npdf(file=\"GEO_FloorPlanK1Errors.pdf\", width = 10, height = 7)\noldPar = par(mar = c(1, 1, 1, 1))\nfloorErrorMap(estXYk1, onlineSummary[ , c(\"posX\",\"posY\")], \n              trainPoints = trainPoints, AP = AP)\npar(oldPar)\ndev.off()\n\ncalcError = \nfunction(estXY, actualXY) \n   sum( rowSums( (estXY - actualXY)^2) )\n\nactualXY = onlineSummary[ , c(\"posX\", \"posY\")]\nsapply(list(estXYk1, estXYk3), calcError, actualXY)\n\n\nv = 11\npermuteLocs = sample(unique(offlineSummary$posXY))\npermuteLocs = matrix(permuteLocs, ncol = v, \n                     nrow = floor(length(permuteLocs)/v))\n\nonlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])\n\nreshapeSS = function(data, varSignal = \"signal\", \n                     keepVars = c(\"posXY\", \"posX\",\"posY\"),\n                     sampleAngle = FALSE, \n                     refs = seq(0, 315, by = 45)) {\n  byLocation =\n    with(data, by(data, list(posXY), \n                  function(x) {\n                    if (sampleAngle) {\n                      x = x[x$angle == sample(refs, size = 1), ]}\n                    ans = x[1, keepVars]\n                    avgSS = tapply(x[ , varSignal ], x$mac, mean)\n                    y = matrix(avgSS, nrow = 1, ncol = 6,\n                               dimnames = list(ans$posXY,\n                                               names(avgSS)))\n                    cbind(ans, y)\n                  }))\n\n  newDataSS = do.call(\"rbind\", byLocation)\n  return(newDataSS)\n}\n\noffline = offline[ offline$mac != \"00:0f:a3:39:dd:cd\", ]\n\nkeepVars = c(\"posXY\", \"posX\",\"posY\", \"orientation\", \"angle\")\n\nonlineCVSummary = reshapeSS(offline, keepVars = keepVars, \n                            sampleAngle = TRUE)\n\nonlineFold = subset(onlineCVSummary, \n                    posXY %in% permuteLocs[ , 1])\n\nofflineFold = subset(offlineSummary,\n                     posXY %in% permuteLocs[ , -1])\n\nestFold = predXY(newSignals = onlineFold[ , 6:11], \n                 newAngles = onlineFold[ , 4], \n                 offlineFold, numAngles = 3, k = 3)\n\nactualFold = onlineFold[ , c(\"posX\", \"posY\")]\ncalcError(estFold, actualFold)\n\nK = 20\nerr = rep(0, K)\n\nfor (j in 1:v) {\n  onlineFold = subset(onlineCVSummary, \n                      posXY %in% permuteLocs[ , j])\n  offlineFold = subset(offlineSummary,\n                       posXY %in% permuteLocs[ , -j])\n  actualFold = onlineFold[ , c(\"posX\", \"posY\")]\n  \n  for (k in 1:K) {\n    estFold = predXY(newSignals = onlineFold[ , 6:11],\n                     newAngles = onlineFold[ , 4], \n                     offlineFold, numAngles = 3, k = k)\n    err[k] = err[k] + calcError(estFold, actualFold)\n  }\n}\n\npdf(file = \"Geo_CVChoiceOfK.pdf\", width = 10, height = 6)\noldPar = par(mar = c(4, 3, 1, 1))\nplot(y = err, x = (1:K),  type = \"l\", lwd= 2,\n     ylim = c(1200, 2100),\n     xlab = \"Number of Neighbors\",\n     ylab = \"Sum of Square Errors\")\n\nrmseMin = min(err)\nkMin = which(err == rmseMin)[1]\nsegments(x0 = 0, x1 = kMin, y0 = rmseMin, col = gray(0.4), \n         lty = 2, lwd = 2)\nsegments(x0 = kMin, x1 = kMin, y0 = 1100,  y1 = rmseMin, \n         col = grey(0.4), lty = 2, lwd = 2)\n\n#mtext(kMin, side = 1, line = 1, at = kMin, col = grey(0.4))\ntext(x = kMin - 2, y = rmseMin + 40, \n     label = as.character(round(rmseMin)), col = grey(0.4))\npar(oldPar)\ndev.off()\n\nestXYk5 = predXY(newSignals = onlineSummary[ , 6:11], \n                 newAngles = onlineSummary[ , 4], \n                 offlineSummary, numAngles = 3, k = 5)\n\ncalcError(estXYk5, actualXY)\n\npredXY = function(newSignals, newAngles, trainData, \n                  numAngles = 1, k = 3){\n  \n  closeXY = list(length = nrow(newSignals))\n  \n  for (i in 1:nrow(newSignals)) {\n    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)\n    closeXY[[i]] = findNN(newSignal = as.numeric(newSignals[i, ]),\n                           trainSS)\n  }\n\n  estXY = lapply(closeXY, function(x)\n                            sapply(x[ , 2:3], \n                                    function(x) mean(x[1:k])))\n  estXY = do.call(\"rbind\", estXY)\n  return(estXY)\n}\n\n```",
    "created" : 1518289312125.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2478804948",
    "id" : "1251FC41",
    "lastKnownWriteTime" : 1518290853,
    "last_content_update" : 1518290853876,
    "path" : "C:/Users/dmurray/AnacondaProjects/MSDS7333/MSDS_7333_CaseStudyUnit6/CaseStudy6.Rmd",
    "project_path" : "CaseStudy6.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled2"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}