{
    "collab_server" : "",
    "contents" : "---\ntitle: \"MAC Addresses\"\noutput: html_notebook\n---\n\nConduct a more thorough data analysis into these two MAC addresses including determining locations by using data corresponding to both MAC addresses.  Which of these two MAC addresses should be used and which should not be used for RTLS? Which MAC address yields the best prediction of location?  Does using data for both MAC addresses simultaneously yield more, or less, accurate prediction of location? (Note: this portion is derived from Exercise Q.9 in Nolan and Lang.)\n\n```{r}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(ggthemes)\n\n```\n\n\nThis sounds like we are trying to compare three different modeling methods for location finding:\n1.  Keep 00:0f:a3:39:e1:c0 and to eliminate the data corresponding to MAC address 00:0f:a3:39:dd:cd. \n2.  Drop 00:0f:a3:39:e1:c0 and to keep the data corresponding to MAC address 00:0f:a3:39:dd:cd. \n3.  Keep both\n\nOur evaluation criteria needs to speak to accuracy - which I would interpret as a higher confidence in the predictions - so having a smaller confidence interval band.\n\nWe know our location\nWe figured out the location of the access points.  Two are at the same location.  One was left out of the analysis.\nCould probably describe the location of access points \nWe know relationships of access points, test locations, signal strengths\n\n\nSignal Strength = angle + distance(x, y)\n\n```{r}\nlist <- c(\"00:0f:a3:39:e1:c0\", \"00:0f:a3:39:dd:cd\")\n\noffline %>% mutate(signal = as.numeric(signal)) %>% filter(mac %in% list) %>% ggplot(aes(x=signal)) + geom_histogram() + theme_light() + facet_wrap(~mac, ncol=2)\n\n```\n```{r}\noffline %>% ggplot(aes(x=posX, y=posY)) + geom_point(alpha=0.05) + theme_light() + facet_grid(~mac)+ geom_jitter()\n\n```\n#Heatmap of each of the two options\n```{r}\n\nparCur = par(mfrow = c(4,2), mar = rep(1, 4)) \n\nmapply(surfaceSS, mac = \"00:0f:a3:39:e1:c0\", angle = rep(c(0, 135,180, 270), 2), data = list(data = offlineSummary))\n\npar(parCur)\n\n#Nolan, Deborah; Lang, Duncan Temple. Data Science in R: A Case Studies Approach to Computational Reasoning and Problem Solving (Chapman & Hall/CRC The R Series) (Page 28). CRC Press. Kindle Edition. \n\n```\n\n```{r}\n#This is the one that was dropped\ncompareMacList <- c(\"00:0f:a3:39:dd:cd\", \"00:0f:a3:39:e1:c0\")\nofflineSummary2 = do.call(\"rbind\", signalSummary)     \n\nparCur = par(mfrow = c(2,2), mar = rep(1, 4)) \n\nmapply(surfaceSS, mac = compareMacList[rep(c(1,2), each=2)], angle = rep(c(90, 135), 2), data = list(data = offlineSummary2))\n\npar(parCur)\n\n#surfaceSS(mac=\"00:0f:a3:39:e1:c0\", angle = 180, data = offlineSummary2)\n\n#Nolan, Deborah; Lang, Duncan Temple. Data Science in R: A Case Studies Approach to Computational Reasoning and Problem Solving (Chapman & Hall/CRC The R Series) (Page 28). CRC Press. Kindle Edition. \n\nunique(offlineSummary2$orientation)\n\n```\nThe access point that was eliminated, shown on the bottom, seems to have some greater uncertainty associated with it. While there's a zone of uncertainty associated with the first, it has a higher degree of certainty and strength of signal close to the suspected base.  \n\n\n\n#Keep e1:c0\n```{r}\n#This is the same as the existing solution, so I don't see anything we need to do outside of run the existing code and say what the value is for error\n# cross validate over each location, using all 8 orientations and 6 MAC addresses\n# each fold has 166/11 = 15 locations\n# must randomly select\nv = 11\n# permute locations\npermuteLocs = sample(unique(offlineSummary$posXY))\n\n# to calculate folds, build a matrix with 11 columns and ~15 locations each\npermuteLocs = matrix(permuteLocs, ncol = v, \n                     nrow = floor(length(permuteLocs)/v))\n\n# get the first validation fold from our offline data\nonlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])\n\n# must re-summarize each fold to match onlineSummary format\n# selecting orientation at random to create our CV folds\nreshapeSS = function(data, varSignal = \"signal\", \n                     keepVars = c(\"posXY\", \"posX\",\"posY\"),\n                     sampleAngle = FALSE, \n                     refs = seq(0, 315, by = 45)) {\n  byLocation =\n    with(data, by(data, list(posXY), \n                  function(x) {\n                    if (sampleAngle) {\n                      x = x[x$angle == sample(refs, size = 1), ]}\n                    ans = x[1, keepVars]\n                    avgSS = tapply(x[ , varSignal ], x$mac, mean)\n                    y = matrix(avgSS, nrow = 1, ncol = 6,\n                               dimnames = list(ans$posXY,\n                                               names(avgSS)))\n                    cbind(ans, y)\n                  }))\n\n  newDataSS = do.call(\"rbind\", byLocation)\n  return(newDataSS)\n}\n\n# exclude MAC\noffline2 = offline[ offline$mac != \"00:0f:a3:39:dd:cd\", ]\n\nkeepVars = c(\"posXY\", \"posX\",\"posY\", \"orientation\", \"angle\")\n\n# build CV base from offline data in general\nonlineCVSummary = reshapeSS(offline2, keepVars = keepVars, \n                            sampleAngle = TRUE)\n\n# an example of one fold\nonlineFold = subset(onlineCVSummary, \n                    posXY %in% permuteLocs[ , 1])\n\n# this is our training set\nofflineFold = subset(offlineSummary,\n                     posXY %in% permuteLocs[ , -1])\n\n# using both methods with k = 3\nestFold = predXY(newSignals = onlineFold[ , 6:11], \n                 newAngles = onlineFold[ , 4], \n                 offlineFold, numAngles = 3, k = 3)\n\nestFoldwtd = predXYwtd(newSignals = onlineFold[ , 6:11], \n                 newAngles = onlineFold[ , 4], \n                 offlineFold, numAngles = 3, k = 3)\n\nactualFold = onlineFold[ , c(\"posX\", \"posY\")]\ncalcError(estFoldwtd, actualFold)\n\n# formally test K out to 20 neighbors\nK = 20\nerr = rep(0, K)\nerr_wtd = rep(0,K) # weighted error\n\nfor (j in 1:v) {\n  onlineFold = subset(onlineCVSummary, \n                      posXY %in% permuteLocs[ , j])\n  offlineFold = subset(offlineSummary,\n                       posXY %in% permuteLocs[ , -j])\n  actualFold = onlineFold[ , c(\"posX\", \"posY\")]\n  \n  for (k in 1:K) {\n    estFold = predXY(newSignals = onlineFold[ , 6:11],\n                     newAngles = onlineFold[ , 4], \n                     offlineFold, numAngles = 3, k = k)\n    err[k] = err[k] + calcError(estFold, actualFold)\n    \n    estFold_wtd = predXYwtd(newSignals = onlineFold[ , 6:11], # add in weighted calculations\n                     newAngles = onlineFold[ , 4], \n                     offlineFold, numAngles = 3, k = k)\n    err_wtd[k] = err_wtd[k] + calcError(estFold_wtd, actualFold)\n  }\n}\n\n#pdf(file = \"Images/Geo_CVChoiceOfK.pdf\", width = 8, height = 6)\noldPar = par(mar = c(4, 3, 1, 1))\nplot(y = err, x = (1:K),  type = \"l\", lwd= 2,\n     ylim = c(0, 2100),\n     xlab = \"Number of Neighbors\",\n     ylab = \"Sum of Square Errors\")\nlines(y=err_wtd, x=1:K, lty = 2, lwd=2, col='red')\n\n\nrmseMin = min(err)\nkMin = which(err == rmseMin)[1]\n\nrmseMin_wtd = min(err_wtd)\nkMin_wtd = which(err_wtd == rmseMin_wtd)[1]\n\n\n\n```\n\n\n#Keep dd:cd\n```{r}\n#Replace e1:c0 with dd:cd in the training data, retrain model, then reevaluate performance\n# cross validate over each location, using all 8 orientations and 6 MAC addresses\n# each fold has 166/11 = 15 locations\n# must randomly select\nv = 11\n# permute locations\npermuteLocs = sample(unique(offlineSummary$posXY))\n\n# to calculate folds, build a matrix with 11 columns and ~15 locations each\npermuteLocs = matrix(permuteLocs, ncol = v, \n                     nrow = floor(length(permuteLocs)/v))\n\n# get the first validation fold from our offline data\nonlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])\n\n# must re-summarize each fold to match onlineSummary format\n# selecting orientation at random to create our CV folds\nreshapeSS = function(data, varSignal = \"signal\", \n                     keepVars = c(\"posXY\", \"posX\",\"posY\"),\n                     sampleAngle = FALSE, \n                     refs = seq(0, 315, by = 45)) {\n  byLocation =\n    with(data, by(data, list(posXY), \n                  function(x) {\n                    if (sampleAngle) {\n                      x = x[x$angle == sample(refs, size = 1), ]}\n                    ans = x[1, keepVars]\n                    avgSS = tapply(x[ , varSignal ], x$mac, mean)\n                    y = matrix(avgSS, nrow = 1, ncol = 6,\n                               dimnames = list(ans$posXY,\n                                               names(avgSS)))\n                    cbind(ans, y)\n                  }))\n\n  newDataSS = do.call(\"rbind\", byLocation)\n  return(newDataSS)\n}\n\n# exclude MAC\noffline3 = offline[ offline$mac != \"00:0f:a3:39:e1:c0\", ]\n\nkeepVars = c(\"posXY\", \"posX\",\"posY\", \"orientation\", \"angle\")\n\n# build CV base from offline data in general\nonlineCVSummary = reshapeSS(offline3, keepVars = keepVars, \n                            sampleAngle = TRUE)\n\n# an example of one fold\nonlineFold = subset(onlineCVSummary, \n                    posXY %in% permuteLocs[ , 1])\n\n# this is our training set\nofflineFold = subset(offlineSummary,\n                     posXY %in% permuteLocs[ , -1])\n\n# using both methods with k = 3\nestFold = predXY(newSignals = onlineFold[ , 6:11], \n                 newAngles = onlineFold[ , 4], \n                 offlineFold, numAngles = 3, k = 3)\n\nestFoldwtd = predXYwtd(newSignals = onlineFold[ , 6:11], \n                 newAngles = onlineFold[ , 4], \n                 offlineFold, numAngles = 3, k = 3)\n\nactualFold = onlineFold[ , c(\"posX\", \"posY\")]\ncalcError(estFoldwtd, actualFold)\n\n# formally test K out to 20 neighbors\nK = 20\nerr = rep(0, K)\nerr_wtd = rep(0,K) # weighted error\n\nfor (j in 1:v) {\n  onlineFold = subset(onlineCVSummary, \n                      posXY %in% permuteLocs[ , j])\n  offlineFold = subset(offlineSummary,\n                       posXY %in% permuteLocs[ , -j])\n  actualFold = onlineFold[ , c(\"posX\", \"posY\")]\n  \n  for (k in 1:K) {\n    estFold = predXY(newSignals = onlineFold[ , 6:11],\n                     newAngles = onlineFold[ , 4], \n                     offlineFold, numAngles = 3, k = k)\n    err[k] = err[k] + calcError(estFold, actualFold)\n    \n    estFold_wtd = predXYwtd(newSignals = onlineFold[ , 6:11], # add in weighted calculations\n                     newAngles = onlineFold[ , 4], \n                     offlineFold, numAngles = 3, k = k)\n    err_wtd[k] = err_wtd[k] + calcError(estFold_wtd, actualFold)\n  }\n}\n\npdf(file = \"Images/Geo_CVChoiceOfK.pdf\", width = 8, height = 6)\noldPar = par(mar = c(4, 3, 1, 1))\nplot(y = err, x = (1:K),  type = \"l\", lwd= 2,\n     ylim = c(0, 2100),\n     xlab = \"Number of Neighbors\",\n     ylab = \"Sum of Square Errors\")\nlines(y=err_wtd, x=1:K, lty = 2, lwd=2, col='red')\n\n\nrmseMin = min(err)\nkMin = which(err == rmseMin)[1]\n\nrmseMin_wtd = min(err_wtd)\nkMin_wtd = which(err_wtd == rmseMin_wtd)[1]\n\n\n# FINDING NEAREST NEIGHBORS\n# takes numeric vector of 6 new signal strengths and result of selectTrain() training set\nfindNN = function(newSignal, trainSubset) {\n  diffs = apply(trainSubset[ , 4:9], 1, \n                function(x) x - newSignal) # this inverts, places x,y on cols when called as.numeric\n  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) # this gets our distance (euclidean)\n  closest = order(dists) # orders our distances in ascending\n  return(trainSubset[closest, 1:3 ]) # returns the subset from training with closest distances, gives xy ID, x, y\n}\n\n\n# weighted nearest neighbors, returns numerator of weight 1/distance\nfindWtdNN = function(newSignal, trainSubset) {\n  diffs = apply(trainSubset[ , 4:9], 1, \n                function(x) x - newSignal) \n  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) \n  closest = order(dists) # orders distances ascending\n  closeXY = trainSubset[closest, 1:3 ]\n  weight = as.numeric(1/dists[closest]) # calculate numerator for weights, we'll filter these based on K in predXY\n  return(cbind(closeXY, weight)) # add in numerator for our weights\n}\n\n# prediction using nearest neighbors from training set\npredXY = function(newSignals, newAngles, trainData, \n                  numAngles = 1, k = 3){\n  \n  closeXY = list(length = nrow(newSignals))\n  \n  for (i in 1:nrow(newSignals)) {\n    trainSS = selectTrain(newAngles[i], trainData, m = numAngles) # select training set based on angle of test obs, num of angles in proximity\n    closeXY[[i]] = findNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # find nearest neighbors, return closest in training set\n  }\n  estXY = lapply(closeXY, # loop over each xy position-based dataframe\n                 function(x) sapply(x[ , 2:3], \n                                    function(x) mean(x[1:k]))) # take a simple average of x,y positions\n  estXY = do.call(\"rbind\", estXY) # pull predictions together for each observation xy in test set\n  return(estXY)\n}\n\n# weighted prediction\npredXYwtd = function(newSignals, newAngles, trainData, \n                     numAngles = 1, k = 3){\n  \n  closeXY = list(length = nrow(newSignals))\n  \n  for (i in 1:nrow(newSignals)) {\n    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)\n    base = findWtdNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # get matrix of x,y, numerator for weights\n    wts = append(base[1:k, 4]/sum(base[1:k, 4]), rep(0, nrow(base)-k))  # calculate weights based on K, append zero array for delta of len-k\n    base[, 2:3] = base[, 2:3]*wts # multiply weights array * matrix of x,y to get weighted vals\n    closeXY[[i]] = base[,1:3] # append weighted xy, x, y values to list\n  }\n  estXY = lapply(closeXY, # loop over each xy position-based dataframe\n                 function(x) sapply(x[ , 2:3], function(x) sum(x))) # sum all as neighbors > k == 0 now, and x,y is already weighted!\n  estXY = do.call(\"rbind\", estXY) # pull predictions together for each observation xy in test set\n  return(estXY)\n}\n\n```\n\n#Keep Both Data\n```{r}\n# cross validate over each location, using all 8 orientations and 6 MAC addresses\n# each fold has 166/11 = 15 locations\n# must randomly select\nv = 11\n# permute locations\npermuteLocs = sample(unique(offlineSummary$posXY))\n\n# to calculate folds, build a matrix with 11 columns and ~15 locations each\npermuteLocs = matrix(permuteLocs, ncol = v, \n                     nrow = floor(length(permuteLocs)/v))\n\n# get the first validation fold from our offline data\nonlineFold = subset(offlineSummary, posXY %in% permuteLocs[ , 1])\n\n# must re-summarize each fold to match onlineSummary format\n# selecting orientation at random to create our CV folds\nreshapeSS = function(data, varSignal = \"signal\", \n                     keepVars = c(\"posXY\", \"posX\",\"posY\"),\n                     sampleAngle = FALSE, \n                     refs = seq(0, 315, by = 45)) {\n  byLocation =\n    with(data, by(data, list(posXY), \n                  function(x) {\n                    if (sampleAngle) {\n                      x = x[x$angle == sample(refs, size = 1), ]}\n                    ans = x[1, keepVars]\n                    avgSS = tapply(x[ , varSignal ], x$mac, mean)\n                    y = matrix(avgSS, nrow = 1, ncol = 6,\n                               dimnames = list(ans$posXY,\n                                               names(avgSS)))\n                    cbind(ans, y)\n                  }))\n\n  newDataSS = do.call(\"rbind\", byLocation)\n  return(newDataSS)\n}\n\n# exclude MAC\n#commented this out for the \"keep both\" question\n#offline = offline[ offline$mac != \"00:0f:a3:39:dd:cd\", ]\n\nkeepVars = c(\"posXY\", \"posX\",\"posY\", \"orientation\", \"angle\")\n\n# build CV base from offline data in general\nonlineCVSummary = reshapeSS(offline2, keepVars = keepVars, \n                            sampleAngle = TRUE)\n\n# an example of one fold\nonlineFold = subset(onlineCVSummary, \n                    posXY %in% permuteLocs[ , 1])\n\n# this is our training set\nofflineFold = subset(offlineSummary,\n                     posXY %in% permuteLocs[ , -1])\n\n# using both methods with k = 3\nestFold = predXY(newSignals = onlineFold[ , 6:11], \n                 newAngles = onlineFold[ , 4], \n                 offlineFold, numAngles = 3, k = 3)\n\nestFoldwtd = predXYwtd(newSignals = onlineFold[ , 6:11], \n                 newAngles = onlineFold[ , 4], \n                 offlineFold, numAngles = 3, k = 3)\n\nactualFold = onlineFold[ , c(\"posX\", \"posY\")]\ncalcError(estFoldwtd, actualFold)\n\n# formally test K out to 20 neighbors\nK = 20\nerr = rep(0, K)\nerr_wtd = rep(0,K) # weighted error\n\nfor (j in 1:v) {\n  onlineFold = subset(onlineCVSummary, \n                      posXY %in% permuteLocs[ , j])\n  offlineFold = subset(offlineSummary,\n                       posXY %in% permuteLocs[ , -j])\n  actualFold = onlineFold[ , c(\"posX\", \"posY\")]\n  \n  for (k in 1:K) {\n    estFold = predXY(newSignals = onlineFold[ , 6:11],\n                     newAngles = onlineFold[ , 4], \n                     offlineFold, numAngles = 3, k = k)\n    err[k] = err[k] + calcError(estFold, actualFold)\n    \n    estFold_wtd = predXYwtd(newSignals = onlineFold[ , 6:11], # add in weighted calculations\n                     newAngles = onlineFold[ , 4], \n                     offlineFold, numAngles = 3, k = k)\n    err_wtd[k] = err_wtd[k] + calcError(estFold_wtd, actualFold)\n  }\n}\n\n#pdf(file = \"Images/Geo_CVChoiceOfK.pdf\", width = 8, height = 6)\noldPar = par(mar = c(4, 3, 1, 1))\nplot(y = err, x = (1:K),  type = \"l\", lwd= 2,\n     ylim = c(0, 2100),\n     xlab = \"Number of Neighbors\",\n     ylab = \"Sum of Square Errors\")\nlines(y=err_wtd, x=1:K, lty = 2, lwd=2, col='red')\n\n\nrmseMin = min(err)\nkMin = which(err == rmseMin)[1]\n\nrmseMin_wtd = min(err_wtd)\nkMin_wtd = which(err_wtd == rmseMin_wtd)[1]\n\n\n\n```",
    "created" : 1518827798435.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4274256803",
    "id" : "3B8D1C0B",
    "lastKnownWriteTime" : 1518875786,
    "last_content_update" : 1518875786260,
    "path" : "C:/Users/dmurray/AnacondaProjects/MSDS7333/MSDS_7333_CaseStudyUnit6/MacAddressInvestigation.Rmd",
    "project_path" : "MacAddressInvestigation.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled2"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}